const fs = require('fs');
const path = require('path');
const {log, info, done} = require('./lib/utils/logger');
const pkg = require(path.join(process.cwd(), 'package.json'));
const NormalModuleReplacementPlugin = require('webpack/lib/NormalModuleReplacementPlugin');

/**
 * @author Vinsea
 * @description 打包时在index.html里添加自定义的js文件，或者打组件时 在 bundle 中加入js脚本 .
 */
class ExtraJsFileWebpackPlugin {

    /**
     * 初始化
     * @param {object} options 配置参数
     */
    constructor(options) {
        const userOptions = options || {};
        const defaultOptions = {
            isComponent: false,
            filename: 'version',
            name: pkg.name,
            version: pkg.version,
            author: pkg.author,
            hash: true,
            pathOnly: false,
            paths: [],
            template: '',
            componentEntry: path.join(process.cwd(), 'src/index.js')
        }
        this.options = Object.assign(defaultOptions, userOptions);
    }

    /**
     * apply is called by the webpack main compiler during the start phase
     * @param {WebpackCompiler} compiler 
     * @returns {undefined}
     */
    apply(compiler) {
        const pathOutputDir = compiler.options.output.path;
        // 不存在就创建
        if (!fs.existsSync(pathOutputDir)) {
            fs.mkdirSync(pathOutputDir);
        }

        // ========================================== 组件模式
        if (this.options.isComponent) {
            const pathOutputFile = path.join(pathOutputDir, 'index-with-version.js');
            this.replaceNormalModule(pathOutputFile);
            new NormalModuleReplacementPlugin(
                new RegExp(this.options.componentEntry),
                pathOutputFile,
            ).apply(compiler);
            info(`已生成 index-with-version.js 为最终入口文件： ${pathOutputFile}`)
            return;
        }

        // ========================================== web项目模式
        compiler.plugin('compilation', (compilation) => {
            // html-webpack-plugin4.* 把钩子名改了，后续规划做兼容
            compilation.plugin('html-webpack-plugin-before-html-processing', (htmlPluginData, callback) => {
                this.options.paths.forEach(pathItem => {
                    log(`插入文件：${pathItem}`);
                    htmlPluginData.assets.js.unshift(pathItem);
                });
                if (this.options.pathOnly) {
                    return;
                }
                this.generateVersionFile(pathOutputDir, htmlPluginData, callback, !compilation.hooks);
            });
        });
    }

    /**
     * 组件模式下 this.options.componentEntry(默认是src/index.js) 
     * 这个入口文件的内容头部增加 this.options.template 的内容
     * @param {string} pathOutputFile 最终的入口文件
     * @returns {undefined}
     */
    replaceNormalModule(pathOutputFile) {
        const entryContent = fs.readFileSync(this.options.componentEntry, 'utf8');
        const template = this.options.template || this.getDefaultTemplateContent();
        const final = `${template}\n${entryContent}`;
        fs.writeFileSync(pathOutputFile, final, 'utf8');
    }

    /**
     * 生成版本文件
     * @param {string} pathOutputDir webpack输出的完整路径
     * @param {Object} htmlPluginData htmlPluginData
     * @param {Function} callback 为了触发promise的resolve
     * @param {Boolean} isBeforeWebpack4 是否是webpack4以前的版本
     * @returns {undefined}
     */
    generateVersionFile(pathOutputDir, htmlPluginData, callback, isBeforeWebpack4) {
        const { hash, filename } = this.options;
        // 获取文件名
        const fileName = hash ? `${filename}.${new Date().getTime()}.js` : `${filename}.js`;
        // 写入文件路径
        const OUTPUT_PATH = path.join(pathOutputDir, fileName);
        // 没有传模板就用自带的
        const template = this.options.template || this.getDefaultTemplateContent();
        // 写入文件
        fs.writeFileSync(OUTPUT_PATH, template, 'utf8');
        done(`已添加到 html-webpack-plugin 资源队列 - ${OUTPUT_PATH}`);
        // 添加到 html-webpack-plugin 资源队列
        htmlPluginData.assets.js.unshift('/' + fileName);
        // [2020-12-10] webpack4之前，为了返回promise，就需要执行callback触发一下resolve
        //              webpack4以后，可以直接用compilation.hooks[EventName].promise()返回promise
        if (isBeforeWebpack4) {
            callback(null, htmlPluginData);
        }
    }

    /**
     * @returns {String} 模板内容
     */
    getDefaultTemplateContent() {
        log('生成默认js内容');
        const now = new Date();
        now.setHours(now.getHours() + 8);
        const current = JSON.stringify({
            name: this.options.name,
            version: this.options.version,
            buildDate: now,
            author: this.options.author,
            dependencies: pkg.dependencies,
        })
        // TODO window上的 key 可以从options里取，并做校验
        return `/* Automatically generated by 'extra-jsfile-webpack-plugin' */
window.__EXTRA_JSFILE_WEBPACK_PLUGIN__ = ${current}
`;
    }

}
module.exports = ExtraJsFileWebpackPlugin;